{"ast":null,"code":"import _toConsumableArray from\"/home/ubuntu/THREATcrawl/threatcrawl/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _slicedToArray from\"/home/ubuntu/THREATcrawl/threatcrawl/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _classCallCheck from\"/home/ubuntu/THREATcrawl/threatcrawl/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/home/ubuntu/THREATcrawl/threatcrawl/node_modules/@babel/runtime/helpers/esm/createClass.js\";import _inherits from\"/home/ubuntu/THREATcrawl/threatcrawl/node_modules/@babel/runtime/helpers/esm/inherits.js\";import _createSuper from\"/home/ubuntu/THREATcrawl/threatcrawl/node_modules/@babel/runtime/helpers/esm/createSuper.js\";import*as React from'react';import{Component}from'react';import{Button}from'@material-ui/core';import WebViewer from'./components/WebViewer';import{labels}from'./LabelLogic';import'../styles/training.css';import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var electron=window.require('electron');var ipcRenderer=electron.ipcRenderer;var remote=electron.remote;/**\n * DoubleCheck is the class that serves as the screen after submitting the highlighted elements in the training screen.\n * \n * In this page, the user sees a trained web page and two buttons: confirm and adjust. \n * \n * If the user confirms the trained web page, then THREAT/crawl has finished training this web page. \n * If the user clicks on 'adjust', then the user is sent back to the training screen.\n * The user can then adjust the inaccurate sections of the structure and train structure again. \n */var DoubleCheck=/*#__PURE__*/function(_Component){_inherits(DoubleCheck,_Component);var _super=_createSuper(DoubleCheck);// Constructor\nfunction DoubleCheck(props){var _this;_classCallCheck(this,DoubleCheck);_this=_super.call(this,props);_this.state={structure:{}};return _this;}_createClass(DoubleCheck,[{key:\"webpageLoaded\",value:function webpageLoaded(){// Get the structure sent by the trainer from the main process\nvar pathsStructure=remote.getGlobal('trained_structure');// Split date formats and identifiers\nvar elemIdentifiers={};var dateFormats={};for(var _i=0,_Object$entries=Object.entries(pathsStructure);_i<_Object$entries.length;_i++){var _Object$entries$_i=_slicedToArray(_Object$entries[_i],2),label=_Object$entries$_i[0],_Object$entries$_i$=_Object$entries$_i[1],identifier=_Object$entries$_i$.identifier,date_format=_Object$entries$_i$.date_format;elemIdentifiers[label]=identifier;dateFormats[label]=date_format;}// Retrieve and highlight the correct elements\nvar structure=this.getElementsFromPath(elemIdentifiers);this.styleElements(structure);// Save the identifiers\nthis.setState({dateFormats:dateFormats});}// Gets all elements from an xPath\n},{key:\"evaluatePath\",value:function evaluatePath(path,innerDoc){// Find all elements\nvar xPathResult=innerDoc.evaluate(path,innerDoc,null,XPathResult.ANY_TYPE,null);// Push each found element to the array\nvar elements=[];var thisElement=xPathResult.iterateNext();while(thisElement){elements.push(thisElement);thisElement=xPathResult.iterateNext();}// Return the found elements\nreturn elements;}// Uses the XPaths to get the DOM elements\n},{key:\"getElementsFromPath\",value:function getElementsFromPath(pathsStructure){var _this2=this;var viewer=document.getElementById('viewer');var innerDoc=viewer.contentDocument;// Object to save the gathered elements\nvar structure={};// Loop over all XPaths to get the elements satisfying that path\nvar _loop=function _loop(){var _Object$entries2$_i=_slicedToArray(_Object$entries2[_i2],2),label=_Object$entries2$_i[0],data=_Object$entries2$_i[1];var elements=[];// Change way of getting the elements depending on the method used\nif(data.HTMLClass){data.HTMLClass.forEach(function(className){var _elements;// Get all elements with a certain class\nvar classResult=innerDoc.getElementsByClassName(className);(_elements=elements).push.apply(_elements,_toConsumableArray(classResult));});}else if(data.XPath){// Evaluate the given xPath\nelements=_this2.evaluatePath(data.XPath,innerDoc);}else if(data.XPathExcept){// Evaluate the given xPath for selected elements\nelements=_this2.evaluatePath(data.XPathExcept.x_path_use,innerDoc);// Evaluate the given xPath for ignored elements\nvar ignored=_this2.evaluatePath(data.XPathExcept.x_path_remove,innerDoc);// Filter ignored elements from the selected elements\nelements=elements.filter(function(e){return!ignored.includes(e);});}// Add elements to the structure Object under the correct label\nstructure[label]=elements;};for(var _i2=0,_Object$entries2=Object.entries(pathsStructure);_i2<_Object$entries2.length;_i2++){_loop();}// Set the structure in the state\nthis.setState({highlightedElements:structure});return structure;}// Add styling to the gathered elements\n},{key:\"styleElements\",value:function styleElements(structure){var _this3=this;var _loop2=function _loop2(){var _Object$entries3$_i=_slicedToArray(_Object$entries3[_i3],2),label=_Object$entries3$_i[0],elements=_Object$entries3$_i[1];elements.forEach(function(element){_this3.styleElement(element,label);});};for(var _i3=0,_Object$entries3=Object.entries(structure);_i3<_Object$entries3.length;_i3++){_loop2();}}// Style one specific element\n},{key:\"styleElement\",value:function styleElement(element,label){// Add border and background color to element \nelement.style.backgroundColor=labels[label].color;element.style.border=\"thin solid rgba(0,0,0, 0.25)\";// Don't try to improve this code, trust me\nvar onClick=function onClick(event){event.target.style.background=labels[label].color;element.removeEventListener('click',onClick);};element.addEventListener('click',onClick);element.click();}// Confirm the trained structure is correct\n},{key:\"confirmStructure\",value:function confirmStructure(){ipcRenderer.send(\"confirmation\",true);remote.getCurrentWindow().close();}// Start training screen to adjust structure\n},{key:\"adjustStructure\",value:function adjustStructure(){ipcRenderer.send(\"confirmation\",false);remote.getCurrentWindow().close();}},{key:\"render\",value:function render(){return/*#__PURE__*/_jsxs(\"div\",{className:\"DoubleCheck\",children:[/*#__PURE__*/_jsx(\"div\",{className:\"DCWebViewer\",children:/*#__PURE__*/_jsx(WebViewer,{on_load:this.webpageLoaded.bind(this),page_url:'file://'+remote.getGlobal('WEBPAGE_DIRECTORY_PATH')+'index.html'})}),/*#__PURE__*/_jsxs(\"div\",{className:\"DoubleCheckButtons\",children:[/*#__PURE__*/_jsx(Button,{onClick:this.confirmStructure,children:\"Confirm\"}),/*#__PURE__*/_jsx(Button,{onClick:this.adjustStructure,children:\"Adjust\"})]})]});}}]);return DoubleCheck;}(Component);export default DoubleCheck;","map":{"version":3,"sources":["/home/ubuntu/THREATcrawl/threatcrawl/src/training_screen/DoubleCheck.js"],"names":["React","Component","Button","WebViewer","labels","electron","window","require","ipcRenderer","remote","DoubleCheck","props","state","structure","pathsStructure","getGlobal","elemIdentifiers","dateFormats","Object","entries","label","identifier","date_format","getElementsFromPath","styleElements","setState","path","innerDoc","xPathResult","evaluate","XPathResult","ANY_TYPE","elements","thisElement","iterateNext","push","viewer","document","getElementById","contentDocument","data","HTMLClass","forEach","className","classResult","getElementsByClassName","XPath","evaluatePath","XPathExcept","x_path_use","ignored","x_path_remove","filter","e","includes","highlightedElements","element","styleElement","style","backgroundColor","color","border","onClick","event","target","background","removeEventListener","addEventListener","click","send","getCurrentWindow","close","webpageLoaded","bind","confirmStructure","adjustStructure"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Component } from 'react';\nimport { Button } from '@material-ui/core';\nimport WebViewer from './components/WebViewer';\nimport { labels } from './LabelLogic';\n\nimport '../styles/training.css';\n\nconst electron = window.require('electron');\nconst ipcRenderer = electron.ipcRenderer;\nconst remote = electron.remote;\n\n\n/**\n * DoubleCheck is the class that serves as the screen after submitting the highlighted elements in the training screen.\n * \n * In this page, the user sees a trained web page and two buttons: confirm and adjust. \n * \n * If the user confirms the trained web page, then THREAT/crawl has finished training this web page. \n * If the user clicks on 'adjust', then the user is sent back to the training screen.\n * The user can then adjust the inaccurate sections of the structure and train structure again. \n */\nclass DoubleCheck extends Component {\n\n    // Constructor\n    constructor(props) {\n        super(props)\n\n        this.state = {\n            structure: {}\n        }\n    }\n\n    webpageLoaded() {\n        // Get the structure sent by the trainer from the main process\n        const pathsStructure = remote.getGlobal('trained_structure');\n\n        // Split date formats and identifiers\n        let elemIdentifiers = {}\n        let dateFormats = {}\n        for (const [label, {identifier, date_format}] of Object.entries(pathsStructure)) {\n            elemIdentifiers[label] = identifier\n            dateFormats[label] = date_format\n        }\n        // Retrieve and highlight the correct elements\n        let structure = this.getElementsFromPath(elemIdentifiers);\n        this.styleElements(structure);\n        // Save the identifiers\n        this.setState({\n            dateFormats: dateFormats\n        })\n    }\n\n    // Gets all elements from an xPath\n    evaluatePath(path, innerDoc) {\n        // Find all elements\n        let xPathResult = innerDoc.evaluate(\n            path,\n            innerDoc,\n            null,\n            XPathResult.ANY_TYPE,\n            null\n        );\n\n        // Push each found element to the array\n        let elements = [];\n        let thisElement = xPathResult.iterateNext();\n        while (thisElement) {\n            elements.push(thisElement)\n            thisElement = xPathResult.iterateNext();\n        }\n\n        // Return the found elements\n        return elements\n    }\n\n    // Uses the XPaths to get the DOM elements\n    getElementsFromPath(pathsStructure) {\n        const viewer = document.getElementById('viewer');\n        const innerDoc = viewer.contentDocument;\n\n        // Object to save the gathered elements\n        let structure = {};\n\n        // Loop over all XPaths to get the elements satisfying that path\n        for (const [label, data] of Object.entries(pathsStructure)) {\n            let elements = []\n\n            // Change way of getting the elements depending on the method used\n            if (data.HTMLClass) {\n                data.HTMLClass.forEach((className) => {\n                    // Get all elements with a certain class\n                    const classResult = innerDoc.getElementsByClassName(className);\n\n                    elements.push(...classResult);\n                })\n            } else if (data.XPath) {\n                // Evaluate the given xPath\n                elements = this.evaluatePath(data.XPath, innerDoc);\n            } else if (data.XPathExcept) {\n                // Evaluate the given xPath for selected elements\n                elements = this.evaluatePath(data.XPathExcept.x_path_use, innerDoc);\n\n                // Evaluate the given xPath for ignored elements\n                let ignored = this.evaluatePath(data.XPathExcept.x_path_remove, innerDoc);\n\n                // Filter ignored elements from the selected elements\n                elements = elements.filter((e) => !ignored.includes(e));\n            }\n\n            // Add elements to the structure Object under the correct label\n            structure[label] = elements;\n        }\n\n        // Set the structure in the state\n        this.setState({\n            highlightedElements: structure\n        });\n\n        return structure\n    }\n\n    // Add styling to the gathered elements\n    styleElements(structure) {\n        for (const [label, elements] of Object.entries(structure)) {\n            elements.forEach((element) => {\n                this.styleElement(element, label);\n            })\n        }\n    }\n\n    // Style one specific element\n    styleElement(element, label) {\n        // Add border and background color to element \n        element.style.backgroundColor = labels[label].color;\n        element.style.border = \"thin solid rgba(0,0,0, 0.25)\";\n\n        // Don't try to improve this code, trust me\n        const onClick = event => {\n            event.target.style.background = labels[label].color;\n            element.removeEventListener('click', onClick);\n        };\n\n        element.addEventListener('click', onClick);\n        element.click();\n    }\n\n    // Confirm the trained structure is correct\n    confirmStructure() {\n        ipcRenderer.send(\"confirmation\", true);\n        remote.getCurrentWindow().close();\n    }\n\n    // Start training screen to adjust structure\n    adjustStructure() {\n        ipcRenderer.send(\"confirmation\", false);\n        remote.getCurrentWindow().close();\n    }\n\n    render() {\n        return (\n            <div className=\"DoubleCheck\">\n                <div className=\"DCWebViewer\">\n                    {/* Render WebViewer */}\n                    <WebViewer\n                        on_load={this.webpageLoaded.bind(this)}\n                        page_url={'file://' + remote.getGlobal('WEBPAGE_DIRECTORY_PATH') + 'index.html'}\n                    />\n                </div>\n                {/* Render buttons to interact */}\n                <div className=\"DoubleCheckButtons\">\n                    <Button onClick={this.confirmStructure} >Confirm</Button>\n                    <Button onClick={this.adjustStructure} >Adjust</Button>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default DoubleCheck;\n"]},"metadata":{},"sourceType":"module"}